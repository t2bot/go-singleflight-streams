package sfstreams

import (
	"errors"
	"fmt"
	"io"
	"sync"

	"golang.org/x/sync/singleflight"
)

// ReaderResult carries the return values of Group.Do over the Group.DoChan channel.
type ReaderResult struct {
	Err    error
	Reader io.ReadCloser
	Shared bool
}

// Group represents a singleflight stream group. This behaves just like a normal singleflight.Group,
// but guarantees a usable (distinct) io.ReadCloser to be returned for each call.
type Group struct {
	sf    singleflight.Group
	mu    sync.Mutex
	calls map[string][]chan<- io.ReadCloser
}

// Do behaves just like singleflight.Group, with the added guarantee that the returned io.ReadCloser
// is unique to the caller. Note that this uses an io.MultiWriter and io.Pipe instances, meaning that
// if one reader fails then all readers generated by the call will fail. The returned readers will
// discard any unread data upon being closed, preventing a single stream being closed ultimately closing
// all streams.
//
// The io.ReadCloser generated by fn is closed internally.
func (g *Group) Do(key string, fn func() (io.ReadCloser, error)) (reader io.ReadCloser, err error, shared bool) {
	g.mu.Lock()
	if g.calls == nil {
		g.calls = make(map[string][]chan<- io.ReadCloser)
	}
	if _, ok := g.calls[key]; !ok {
		g.calls[key] = make([]chan<- io.ReadCloser, 0)
	}
	resCh := make(chan io.ReadCloser)
	defer close(resCh)
	g.calls[key] = append(g.calls[key], resCh)

	valCh := g.sf.DoChan(key, g.doWork(key, fn))
	g.mu.Unlock()

	res := <-valCh
	return <-resCh, res.Err, res.Shared
}

// DoChan runs Group.Do, but returns a channel that will receive the results/stream when ready.
//
// The returned channel is not closed.
func (g *Group) DoChan(key string, fn func() (io.ReadCloser, error)) <-chan ReaderResult {
	ch := make(chan ReaderResult)
	go func(ch chan ReaderResult, g *Group) {
		r, err, shared := g.Do(key, fn)
		ch <- ReaderResult{
			Err:    err,
			Reader: r,
			Shared: shared,
		}
	}(ch, g)
	return ch
}

// Forget acts just like singleflight.Group.
func (g *Group) Forget(key string) {
	g.mu.Lock()
	if chans, ok := g.calls[key]; ok {
		for _, ch := range chans {
			close(ch)
		}
	}
	delete(g.calls, key)
	g.sf.Forget(key)
	g.mu.Unlock()
}

func (g *Group) doWork(key string, fn func() (io.ReadCloser, error)) func() (interface{}, error) {
	return func() (interface{}, error) {
		fnRes, fnErr := fn()

		g.mu.Lock()
		defer g.mu.Unlock()
		g.sf.Forget(key) // we won't be processing future calls, so wrap it up
		if chans, ok := g.calls[key]; !ok {
			return nil, errors.New(fmt.Sprintf("expected to find singleflight key \"%s\", but didn't", key))
		} else {
			skipStream := fnRes == nil
			writers := make([]io.Writer, 0) // they're actually PipeWriters, but the MultiWriter doesn't like that...
			for _, ch := range chans {
				if skipStream {
					// This needs to be async to prevent a deadlock
					go func(ch chan<- io.ReadCloser) {
						ch <- nil
					}(ch)
					continue
				}

				r, w := io.Pipe()
				writers = append(writers, w) // if `w` becomes a non-PipeWriter, fix `writers` array usage.

				// This needs to be async to prevent a deadlock
				go func(r io.ReadCloser, ch chan<- io.ReadCloser) {
					ch <- newDiscardCloser(r)
				}(r, ch)
			}
			delete(g.calls, key) // we've done all we can for this call: clear it before we unlock

			if !skipStream {
				// Do the io copy async to prevent holding up other singleflight calls
				go finishCopy(writers, fnRes)
			}

			return nil, fnErr // we discard the return value
		}
	}
}

func finishCopy(writers []io.Writer, fnRes io.ReadCloser) {
	//goland:noinspection GoUnhandledErrorResult
	defer fnRes.Close()
	mw := io.MultiWriter(writers...)
	_, copyErr := io.Copy(mw, fnRes)
	for _, w := range writers {
		cw := w.(*io.PipeWriter) // guaranteed with above code in doWork
		if copyErr != nil {
			_ = cw.CloseWithError(copyErr)
		} else {
			_ = cw.Close()
		}
	}
}

// discardCloser discards any remaining data on the underlying reader on close.
type discardCloser struct {
	io.ReadCloser
	r io.ReadCloser
}

// newDiscardCloser creates a new discardCloser from an input io.ReadCloser
func newDiscardCloser(r io.ReadCloser) *discardCloser {
	return &discardCloser{r: r}
}

func (d *discardCloser) Read(p []byte) (int, error) {
	return d.r.Read(p)
}

func (d *discardCloser) Close() error {
	if _, err := io.Copy(io.Discard, d.r); err != nil {
		return err
	}
	return d.r.Close()
}
